#!/usr/bin/env bash
# userctl - per-user SNAT + TC shaping (nft + tc)
# INPUT: up/down in kbit (50000 = 50Mbit)
# OUTPUT: UP/DOWN in Mbit/Gbit
# CALL show: sudo bash ./userctl show <ip>

set -euo pipefail

# ----------------- CONFIG -----------------
LAN_IFS="ens1f1"
WAN_IFS="vlan3310 ens1f0"

NFT_FAMILY="inet"
NFT_TABLE="firewall"
NFT_SET="allowed_clients"
NFT_MAP="client_mark"

NAT_FAMILY="ip"
NAT_TABLE="nat"
NAT_MAP="public_pool_map"

TC_ROOT_HANDLE="1:"
TC_ROOT_DEFAULT="999"
TC_R2Q="100"

TC_UNIT="kbit"
BANDWIDTH="10000000kbit"  # 10Gbit
# -------------------------------------------

usage() {
cat <<EOF
Usage:
	userctl add <ip> <up_kbit> <down_kbit> [public-ip]
	userctl del <ip>
	userctl list
	userctl show <ip>   # call via: sudo bash ./userctl show <ip>
	Example:
	userctl add 192.168.99.99 50000 60000 203.0.113.1
	sudo bash ./userctl show 192.168.99.99
EOF
	exit 1
}

to_tc_unit() {
	local kbit=$1
	[[ "$kbit" =~ ^[0-9]+$ ]] || { echo "Error: kbit must be integer"; exit 1; }
	echo "${kbit}kbit"
}

normalize_rate() {
	local r=$1
	if [[ $r =~ ^([0-9]+)kbit$ ]]; then
	local kbit=${BASH_REMATCH[1]}
	if (( kbit >= 1000000 )); then
	echo "$((kbit / 1000000))Gbit"
	elif (( kbit >= 1000 )); then
	echo "$((kbit / 1000))Mbit"
	else
	echo "${kbit}kbit"
	fi
	else
	echo "$r"
	fi
}

gen_mark() {
	local ip=$1
	IFS='.' read -r a b c d <<< "$ip"
	c=${c:-0}; d=${d:-0}
	printf "%d" $(( (c << 8) + d ))
}

get_class_minor() {
	local mark=$1
	echo $(( (mark % 60000) + 1000 ))
}

is_valid_ip() {
	local ip=$1
	[[ $ip =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] && {
		IFS='.' read -r a b c d <<< "$ip"
		[[ $a -le 255 && $b -le 255 && $c -le 255 && $d -le 255 ]]
	}
}

ensure_sets_maps() {
	nft list set ${NFT_FAMILY} ${NFT_TABLE} ${NFT_SET} &>/dev/null || \
	nft add set ${NFT_FAMILY} ${NFT_TABLE} ${NFT_SET} "{ type ipv4_addr; flags interval; }"
	nft list map ${NFT_FAMILY} ${NFT_TABLE} ${NFT_MAP} &>/dev/null || \
	nft add map ${NFT_FAMILY} ${NFT_TABLE} ${NFT_MAP} "{ type ipv4_addr: mark; }"
	nft list map ${NAT_FAMILY} ${NAT_TABLE} ${NAT_MAP} &>/dev/null || \
	nft add map ${NAT_FAMILY} ${NAT_TABLE} ${NAT_MAP} "{ type ipv4_addr: ipv4_addr; }"
}

get_mark() {
	local ip=$1
	nft list map ${NFT_FAMILY} ${NFT_TABLE} ${NFT_MAP} 2>/dev/null | \
	awk -v k="$ip" '
	{ data = data $0 " " }
	END {
		gsub(/[ \t{}]/,"", data);
		sub(/^.*elements=/, "", data);
		sub(/\}.*$/, "", data);
		split(data, elems, ",");
		for (e in elems) {
			split(elems[e], parts, ":");
			if (parts[1] == k) {
				gsub(/^0x/, "", parts[2]);
				print ("0x" parts[2] + 0);
				exit
			}
		}
	}' || echo ""
}

get_public_ip() {
	local ip=$1
	nft list map ${NAT_FAMILY} ${NAT_TABLE} ${NAT_MAP} 2>/dev/null | \
	awk -v k="$ip" '
	{ data = data $0 " " }
	END {
		gsub(/[ \t{}]/,"", data);
		sub(/^.*elements=/, "", data);
		sub(/\}.*$/, "", data);
		split(data, elems, ",");
		for (e in elems) {
			split(elems[e], parts, ":");
			if (parts[1] == k) { print parts[2]; exit }
		}
	}' || echo ""
}

list_allowed_ips() {
	nft list set ${NFT_FAMILY} ${NFT_TABLE} ${NFT_SET} 2>/dev/null | \
	awk '
	{ data = data $0 " " }
	END {
		gsub(/[ \t{}]/,"", data);
		sub(/^.*elements=/, "", data);
		sub(/\}.*$/, "", data);
		split(data, a, ",");
		for (i in a) if (a[i]) print a[i];
	}'
}

delete_nat_mapping_by_key() {
	local ip="$1"
	nft list map ${NAT_FAMILY} ${NAT_TABLE} ${NAT_MAP} 2>/dev/null | \
	awk -v ip="$ip" '
	{ data = data $0 " " }
	END {
		gsub(/[ \t{}]/,"", data);
		sub(/^.*elements=/, "", data);
		sub(/\}.*$/, "", data);
		split(data, elems, ",");
		for (e in elems) {
			split(elems[e], parts, ":");
			if (parts[1] == ip) print parts[1] ":" parts[2]
		}
	}' | \
	while IFS=: read -r key val; do
	nft delete element ${NAT_FAMILY} ${NAT_TABLE} ${NAT_MAP} "{ ${key} : ${val} }" 2>/dev/null || true
	done
}

ensure_tc_root() {
	local ifc=$1
	local bw_converted=$(to_tc_unit "$BANDWIDTH")
	
	tc qdisc show dev "$ifc" | grep -q "htb.*root" || \
	tc qdisc add dev "$ifc" root handle ${TC_ROOT_HANDLE} htb default ${TC_ROOT_DEFAULT} r2q ${TC_R2Q}
	
	tc class show dev "$ifc" | grep -q "1:1" || \
	tc class add dev "$ifc" parent ${TC_ROOT_HANDLE} classid 1:1 htb rate $bw_converted ceil $bw_converted
	
	tc class show dev "$ifc" | grep -q "1:${TC_ROOT_DEFAULT}" || \
	tc class add dev "$ifc" parent 1:1 classid 1:${TC_ROOT_DEFAULT} htb rate $bw_converted ceil $bw_converted
}

get_tc_rate_for_mark() {
	local ifc=$1; local mark=$2
	local minor=$(get_class_minor "$mark")
	local classid_hex=$(printf "1:%x" "$minor")
	
	tc class show dev "$ifc" 2>/dev/null | \
	awk -v cls="$classid_hex" '
	$0 ~ cls {
		r = ""; c = ""
		for (i=1; i<=NF; i++) {
			if ($i == "rate") r = $(i+1)
			if ($i == "ceil") c = $(i+1)
		}
		if (r && c) print r "," c
		else if (r) print r
		exit
	}'
}

cmd_add() {
	local ip=$1 up_kbit=$2 down_kbit=$3 pubip="${4:-}"
	
	[[ -z "$ip" || -z "$up_kbit" || -z "$down_kbit" ]] && usage
	! is_valid_ip "$ip" && { echo "Error: Invalid IP $ip"; exit 1; }
	! [[ "$up_kbit" =~ ^[0-9]+$ && "$down_kbit" =~ ^[0-9]+$ ]] && { echo "Error: up/down must be integers (kbit)"; exit 1; }
	
	ensure_sets_maps
	for ifc in $LAN_IFS $WAN_IFS; do ensure_tc_root "$ifc"; done
	
	local mark=$(get_mark "$ip")
	[[ -z "$mark" || "$mark" -eq 0 ]] && mark=$(gen_mark "$ip")
	
	local assign_pub=""
	[[ -n "$pubip" ]] && { ! is_valid_ip "$pubip" && { echo "Error: Invalid public IP"; exit 1; }; assign_pub="$pubip"; }
	
	local up_mbit=$((up_kbit / 1000))
	local down_mbit=$((down_kbit / 1000))
	echo "[+] updating $ip mark=$mark up=${up_mbit}M down=${down_mbit}M public=${assign_pub:-<none>}"
	
	nft replace element ${NFT_FAMILY} ${NFT_TABLE} ${NFT_SET} "{ $ip }" 2>/dev/null || \
	nft add element ${NFT_FAMILY} ${NFT_TABLE} ${NFT_SET} "{ $ip }"
	
	nft delete element ${NFT_FAMILY} ${NFT_TABLE} ${NFT_MAP} "{ $ip }" 2>/dev/null || true
	nft add element ${NFT_FAMILY} ${NFT_TABLE} ${NFT_MAP} "{ $ip : $mark }"
	
	[[ -n "$assign_pub" ]] && {
		delete_nat_mapping_by_key "$ip"
		nft add element ${NAT_FAMILY} ${NAT_TABLE} ${NAT_MAP} "{ $ip : $assign_pub }"
	}
	
	local minor=$(get_class_minor "$mark")
	local classid_hex=$(printf "0x1:0x%x" "$minor")
	local up_rate=$(to_tc_unit "$up_kbit")
	local down_rate=$(to_tc_unit "$down_kbit")
	
	for ifc in $LAN_IFS; do
	tc filter del dev "$ifc" parent ${TC_ROOT_HANDLE} protocol ip prio 1 u32 match ip src ${ip}/32 2>/dev/null || true
	tc class del dev "$ifc" classid $classid_hex 2>/dev/null || true
	tc class add dev "$ifc" parent 1:1 classid $classid_hex htb rate $up_rate ceil $up_rate || echo "Warning: LAN $ifc"
	tc qdisc add dev "$ifc" parent $classid_hex fq || true
	tc filter add dev "$ifc" parent ${TC_ROOT_HANDLE} protocol ip prio 1 u32 match ip src ${ip}/32 flowid $classid_hex || true
	done
	
	for ifc in $WAN_IFS; do
	tc filter del dev "$ifc" parent ${TC_ROOT_HANDLE} protocol ip prio 1 handle ${mark} fw 2>/dev/null || true
	tc class del dev "$ifc" classid $classid_hex 2>/dev/null || true
	tc class add dev "$ifc" parent 1:1 classid $classid_hex htb rate $down_rate ceil $down_rate || echo "Warning: WAN $ifc"
	tc qdisc add dev "$ifc" parent $classid_hex fq || true
	tc filter add dev "$ifc" parent ${TC_ROOT_HANDLE} protocol ip prio 1 handle ${mark} fw classid $classid_hex || true
	done
	
	echo "[OK] updated"
}

cmd_del() {
	local ip=$1
	[[ -z "$ip" ]] && usage
	! is_valid_ip "$ip" && { echo "Error: Invalid IP $ip"; exit 1; }
	
	local mark=$(get_mark "$ip")
	[[ -z "$mark" || "$mark" -eq 0 ]] && mark=$(gen_mark "$ip")
	
	echo "[-] removing $ip mark=$mark"
	
	nft delete element ${NFT_FAMILY} ${NFT_TABLE} ${NFT_SET} "{ $ip }" 2>/dev/null || true
	nft delete element ${NFT_FAMILY} ${NFT_TABLE} ${NFT_MAP} "{ $ip }" 2>/dev/null || true
	delete_nat_mapping_by_key "$ip"
	
	local minor=$(get_class_minor "$mark")
	local classid_hex=$(printf "0x1:0x%x" "$minor")
	
	for ifc in $LAN_IFS; do
	tc filter del dev "$ifc" parent ${TC_ROOT_HANDLE} protocol ip prio 1 u32 match ip src ${ip}/32 2>/dev/null || true
	tc class del dev "$ifc" classid $classid_hex 2>/dev/null || true
	done
	for ifc in $WAN_IFS; do
	tc filter del dev "$ifc" parent ${TC_ROOT_HANDLE} protocol ip prio 1 handle ${mark} fw 2>/dev/null || true
	tc class del dev "$ifc" classid $classid_hex 2>/dev/null || true
	done
	
	echo "[OK] removed"
}

cmd_list() {
	ensure_sets_maps
	for ifc in $LAN_IFS $WAN_IFS; do ensure_tc_root "$ifc"; done
	
	printf "%-16s %-8s %-10s %-10s %-16s\n" "IP" "MARK" "UP" "DOWN" "PUBLIC-IP"
	printf "%s\n" "--------------------------------------------------------------------------------"
	
	list_allowed_ips | sort -t . -k1,1n -k2,2n -k3,3n -k4,4n | while read -r ip; do
	[[ -z "$ip" ]] && continue
	local mark=$(get_mark "$ip")
	[[ -z "$mark" ]] && mark=$(gen_mark "$ip")
	local pub=$(get_public_ip "$ip"); [[ -z "$pub" ]] && pub="—"
	
	local first_lan=$(echo "$LAN_IFS" | awk '{print $1}')
	local first_wan=$(echo "$WAN_IFS" | awk '{print $1}')
	local up_raw=$(get_tc_rate_for_mark "$first_lan" "$mark")
	local down_raw=$(get_tc_rate_for_mark "$first_wan" "$mark")
	
	local up=$(echo "$up_raw" | cut -d',' -f1 | xargs)
	local down=$(echo "$down_raw" | cut -d',' -f1 | xargs)
	
	up=$(normalize_rate "$up")
	down=$(normalize_rate "$down")
	[[ -z "$up" ]] && up="—"
	[[ -z "$down" ]] && down="—"
	
	printf "%-16s %-8s %-10s %-10s %-16s\n" "$ip" "$mark" "$up" "$down" "$pub"
	done
}

cmd_show() {
	local ip=$1
	[[ -z "$ip" ]] && usage
	ensure_sets_maps
	
	echo "=== $ip ==="
	list_allowed_ips | grep -q "^${ip}$" && echo "allowed: yes" || echo "allowed: no"
	
	local mark=$(get_mark "$ip")
	[[ -z "$mark" ]] && mark=$(gen_mark "$ip")
	echo "mark: $mark"
	
	local pub=$(get_public_ip "$ip")
	echo "public ip: ${pub:-(none)}"
	
	local minor=$(get_class_minor "$mark")
	local classid_hex=$(printf "1:%x" "$minor")
	
	echo "TC classes:"
	for ifc in $LAN_IFS; do
	echo "  LAN $ifc:"
	tc class show dev "$ifc" | grep "$classid_hex" || echo "   (no class)"
	done
	for ifc in $WAN_IFS; do
	echo "  WAN $ifc:"
	tc class show dev "$ifc" | grep "$classid_hex" || echo "   (no class)"
	done
	
	local first_lan=$(echo "$LAN_IFS" | awk '{print $1}')
	local first_wan=$(echo "$WAN_IFS" | awk '{print $1}')
	local up_raw=$(get_tc_rate_for_mark "$first_lan" "$mark")
	local down_raw=$(get_tc_rate_for_mark "$first_wan" "$mark")
	local up=$(echo "$up_raw" | cut -d',' -f1 | xargs)
	local down=$(echo "$down_raw" | cut -d',' -f1 | xargs)
	up=$(normalize_rate "$up")
	down=$(normalize_rate "$down")
	echo "Rates: UP=${up:-(none)} DOWN=${down:-(none)}"
}

cmd_status() { cmd_show "$1"; }

[[ $# -lt 1 ]] && usage
cmd=$1; shift
case "$cmd" in
add) cmd_add "$@" ;;
del) cmd_del "$1" ;;
list) cmd_list ;;
show|status) cmd_show "$1" ;;
*) usage ;;
esac

exit 0
