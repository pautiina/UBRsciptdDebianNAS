#!/usr/sbin/nft -f

flush ruleset

################################################################
# NAT table (round-robin SNAT pool + static map)
################################################################
table ip nat {
    # Real IP bypass (transit networks) - не NATим
    set real_ip_bypass {
        type ipv4_addr
        flags interval
        elements = { 1.1.1.32/27 }
    }
    
    # Сеть(и) клиентов (можно адаптировать под конкретную подсеть)
    set LOCAL_NET_v4 {
        type ipv4_addr
        flags interval
        auto-merge
        elements = { 10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12 }
    }
    
    # WAN интерфейсы (используется в oifname)
    set I_WAN {
        type ifname
        flags interval
        auto-merge
        elements = { "vlan3310" }
    }
    
    # Map: префикс (или отдельный IP) -> фиксированный внешний IP (persistent SNAT)
    map public_pool_map {
        type ipv4_addr : ipv4_addr
        # ключи могут быть подсетями или отдельными адресами; значения — внешние адреса
        # initially empty; example:
        # elements = { 10.10.162.26 : 1.1.1.192 }
    }
    
    # Map: префикс (или отдельный IP) -> фиксированный внешний IP (persistent SNAT)
    map public_pool_map_static {
        type ipv4_addr : ipv4_addr
        flags interval
        # ключи могут быть подсетями или отдельными адресами; значения — внешние адреса
        elements = {
            10.10.0.0/24 : 1.1.1.192,
            10.10.162.27 : 1.1.1.195,
            # добавляй по необходимости
        }
    }

    chain prerouting {
        type nat hook prerouting priority -100; policy accept;
    }
    
    chain postrouting {
        #type nat hook postrouting priority 100; policy accept;
        type nat hook postrouting priority srcnat; policy accept;
        
        # 1) Не NATим traffic от реального пула (он маршрутится напрямую)
        ip saddr @real_ip_bypass return;
        
        # 2) Если есть статическая привязка (map) — используем её и делаем persistent SNAT, создается скриптом userctl
#        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to ip saddr map @public_pool_map persistent;
        
        # 3) Если есть статическая привязка (map) — используем её и делаем persistent SNAT
#        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to ip saddr map @public_pool_map_static persistent;
        
        # 4) Если статической привязки нет — используй round-robin диапазон (sticky per-conn)
#        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to 1.1.1.192-1.1.1.222 persistent;
        
        # 5) Фолбэк: обычный masquerade для всего остального, уходящего на WAN
        oifname @I_WAN masquerade;
    }
}

################################################################
# Firewall / marking table (mark ставится для разрешённых клиентов -> используется tc)
################################################################
table inet firewall {
    # Whitelist: хости, які доступні навіть при виключеному інтернеті
    set allowed_hosts {
        type ipv4_addr
        flags interval
	elements = { 46.172.83.106 }
    }

    # Список разрешенных DNS серверов
    set allowed-dns-servers {
        type ipv4_addr
        elements = { 1.1.1.1, 1.0.0.1, 8.8.8.8, 8.8.4.4 }
    }

    # Whitelist: клиенты, которым разрешён выход в интернет
    set allowed_clients {
        type ipv4_addr
        flags interval
        #auto-merge
    }
    
    # Map: private IP -> fwmark (число)
    # Map for downloads
    map client_mark_d {
        type ipv4_addr : mark
        # элементы добавляются командой nft add element inet firewall client_mark { 10.10.162.26 : 1001 }
    }
    
    # Map: private IP -> fwmark (число)
    # Map for uploads
    map client_mark_u {
        type ipv4_addr : mark
        # элементы добавляются командой nft add element inet firewall client_mark { 10.10.162.26 : 1001 }
    }

    # WAN and LAN sets (локально в этой таблице, для удобства)
    set I_LAN {
        type ifname
        flags interval
        elements = { "vlan165" }
    }
    set I_WAN {
        type ifname
        flags interval
        elements = { "vlan3310" }
    }
    
    # Mangle: проставление meta mark ТОЛЬКО для разрешённых клиентов
    chain mangle_pre {
        type filter hook prerouting priority mangle;  policy accept;

        #meta mark != 0 counter log prefix "MARKED: ";

    }

    # UPLOAD: клиент → интернет (до SNAT)
    chain mangle_up {
        type filter hook prerouting priority mangle; policy accept;
        #iifname @I_LAN ip saddr @allowed_clients meta mark set ip saddr map @client_mark_u mark set meta mark counter log prefix "UP_MARK: ";
        iifname @I_LAN ip saddr @allowed_clients meta mark set ip saddr map @client_mark_u mark set meta mark;
    }

    # DOWNLOAD: интернет → клиент (daddr уже внутренний)
    chain mangle_down {
        type filter hook postrouting priority 100; policy accept;
        #oifname @I_LAN ip daddr @allowed_clients meta mark set ip daddr map @client_mark_d counter log prefix "DOWN_MARK: ";
        oifname @I_LAN ip daddr @allowed_clients meta mark set ip daddr map @client_mark_d;
    }
    
    # Основная фильтрация: разрешаем только whitelisted клиентов идти в интернет
    chain forward {
        type filter hook forward priority 0; policy drop;

        # Разрешаем все соединения на петлевом интерфейсе
        iif "lo" accept
        
        # allow established related
#        ct state established,related accept;
        	ct state vmap { established : accept, related : accept, invalid : drop }
        
        # LAN -> WAN: дозволені хости
        iifname @I_LAN ip daddr @allowed_hosts oifname  @I_WAN accept;
        
        # LAN -> WAN: дозволені хости
        iifname @I_WAN ip saddr @allowed_hosts oifname  @I_LAN accept;

        # Разрешаем отправку DNS-запросов по UDP
        ip daddr @allowed-dns-servers udp dport 53 accept
        
        # Разрешаем отправку DNS-запросов по TCP
        ip daddr @allowed-dns-servers tcp dport 53 accept

        # BILLING
        # LAN -> WAN: только разрешённые клиенты
        iifname @I_LAN ip saddr @allowed_clients oifname  @I_WAN accept;
        
        # LAN -> WAN: только разрешённые клиенты
        iifname @I_WAN ip daddr @allowed_clients oifname  @I_LAN accept;

        # LAN <-> LAN внутри сети разрешаем
        iifname @I_LAN oifname @I_LAN accept;
        
        # log and drop others
        limit rate over 1/second  log prefix "BLOCKED_CLIENT: " flags all;
        drop;
    }
    
    # Остальные цепочки (input/output) — по умолчанию принимаем (если надо, можно ужесточить)
    chain input {
        type filter hook input priority 0; policy accept;

        # Разрешаем все соединения на петлевом интерфейсе
        iif "lo" accept;

        # Разрешаем уже установленные соединения
        ct state vmap { established : accept, related : accept, invalid : drop };
    }
    
    chain output {
        type filter hook output priority 0; policy accept;

        # Разрешаем все исходящие соединения
        oif "lo" accept;

        # Разрешаем уже установленные соединения
        ct state vmap { established : accept, related : accept, invalid : drop };

        # Разрешаем Интернет на шлюзе
        tcp dport { 80, 443 } accept;

        # Разрешаем DNS
        meta l4proto { tcp, udp } th dport 53 accept;

        # Разрешаем исходящий ICMP request (ping)
        icmp type echo-request accept;

        # Разрешаем NTP
        udp dport 123 accept;
    }
}
table ip conntrack {
    ct helper ftp_tcp {
        type "ftp" protocol tcp
        l3proto ip
    }
    
    ct helper pptp_tcp {
        type "pptp" protocol tcp
        l3proto ip
    }
    
#    ct helper rpc_tcp {
#        type "rpc" protocol tcp
#        l3proto ip
#    }
    
#    ct helper rpc_udp {
#        type "rpc" protocol udp
#        l3proto ip
#    }
    
    ct helper sip_tcp {
        type "sip" protocol tcp
        l3proto ip
    }
    
    ct helper sip_udp {
        type "sip" protocol udp
        l3proto ip
    }
    
    chain CT_IGNORE {
        return
    }
    
    chain CT_TIMEOUT {
        return
    }
    
    chain PREROUTING {
        type filter hook prerouting priority raw; policy accept;
        counter jump CT_IGNORE
        counter jump CT_TIMEOUT
        counter jump FW_CONNTRACK
        counter jump NAT_CONNTRACK
        counter jump WLB_CONNTRACK
        notrack
    }
    
    chain PREROUTING_HELPER {
        type filter hook prerouting priority filter - 5; policy accept;
        counter jump CT_HELPER
    }
    
    chain OUTPUT {
        type filter hook output priority raw; policy accept;
        counter jump CT_IGNORE
        counter jump CT_TIMEOUT
        counter jump FW_CONNTRACK
        counter jump NAT_CONNTRACK
        notrack
    }
    
    chain OUTPUT_HELPER {
        type filter hook output priority filter - 5; policy accept;
        counter jump CT_HELPER
    }
    
    chain CT_HELPER {
        tcp dport 21 ct helper set "ftp_tcp" return
#        tcp dport 111 ct helper set "rpc_tcp" return
#        udp dport 111 ct helper set "rpc_udp" return
        tcp dport 1723 ct helper set "pptp_tcp" return
        tcp dport { 5060, 5061 } ct helper set "sip_tcp" return
        udp dport { 5060, 5061 } ct helper set "sip_udp" return
        return
    }
    
    chain FW_CONNTRACK {
        accept
    }
    
    chain NAT_CONNTRACK {
        accept
    }
    
    chain WLB_CONNTRACK {
        return
    }
}
