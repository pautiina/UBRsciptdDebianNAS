#!/usr/sbin/nft -f

flush ruleset

################################################################
# NAT table (round-robin SNAT pool + static map)
################################################################
table ip nat {
    # Real IP bypass (transit networks) - не NATим
    set real_ip_bypass {
        type ipv4_addr
        flags interval
        elements = { 1.1.1.32/27 }
    }
    
    # Сеть(и) клиентов (можно адаптировать под конкретную подсеть)
    set LOCAL_NET_v4 {
        type ipv4_addr
        flags interval
        auto-merge
        elements = { 10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12 }
    }
    
    # WAN интерфейсы (используется в oifname)
    set I_WAN {
        type ifname
        flags interval
        auto-merge
        elements = { "ens1f0.3310", "vlan3310" }
    }
    
    # Map: префикс (или отдельный IP) -> фиксированный внешний IP (persistent SNAT)
    map public_pool_map {
        type ipv4_addr : ipv4_addr
        # ключи могут быть подсетями или отдельными адресами; значения — внешние адреса
        # initially empty; example:
        # elements = { 10.10.162.26 : 1.1.1.192 }
    }
    
    # Map: префикс (или отдельный IP) -> фиксированный внешний IP (persistent SNAT)
    map public_pool_map_static {
        type ipv4_addr : ipv4_addr
        flags interval
        # ключи могут быть подсетями или отдельными адресами; значения — внешние адреса
        elements = {
            10.10.0.0/24 : 1.1.1.192,
            10.10.162.27 : 1.1.1.195,
            # добавляй по необходимости
        }
    }

    chain prerouting {
        type nat hook prerouting priority -100; policy accept;
    }
    
    chain postrouting {
        type nat hook postrouting priority 100; policy accept;
        
        # 1) Не NATим traffic от реального пула (он маршрутится напрямую)
        ip saddr @real_ip_bypass return;
        
        # 2) Если есть статическая привязка (map) — используем её и делаем persistent SNAT, создается скриптом userctl
        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to ip saddr map @public_pool_map persistent;
        
        # 3) Если есть статическая привязка (map) — используем её и делаем persistent SNAT
        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to ip saddr map @public_pool_map_static persistent;
        
        # 4) Если статической привязки нет — используй round-robin диапазон (sticky per-conn)
        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to 1.1.1.192-1.1.1.222 persistent;
        
        # 5) Фолбэк: обычный masquerade для всего остального, уходящего на WAN
        oifname @I_WAN masquerade;
    }
}

################################################################
# Firewall / marking table (mark ставится для разрешённых клиентов -> используется tc)
################################################################
table inet firewall {
    # Whitelist: клиенты, которым разрешён выход в интернет
    set allowed_clients {
        type ipv4_addr
        flags interval
        #auto-merge
        # initially empty; управлять через nft add element / userctl
    }
    
    # Map: private IP -> fwmark (число)
    # Map for downloads
    map client_mark_d {
        type ipv4_addr : mark
        # элементы добавляются командой nft add element inet firewall client_mark { 10.10.162.26 : 1001 }
    }
    
    # Map: private IP -> fwmark (число)
    # Map for uploads
    map client_mark_u {
        type ipv4_addr : mark
        # элементы добавляются командой nft add element inet firewall client_mark { 10.10.162.26 : 1001 }
    }

    # WAN and LAN sets (локально в этой таблице, для удобства)
    set I_LAN {
        type ifname
        flags interval
        elements = { "ens1f1", "vlan100", "ens1f1.100" }
    }
    set I_WAN {
        type ifname
        flags interval
        elements = { "ens1f0.3310", "vlan3310", "ens1f0.3310" }
    }
    
    # Mangle: проставление meta mark ТОЛЬКО для разрешённых клиентов
    chain mangle_pre {
        type filter hook prerouting priority mangle; policy accept;
        
        # set meta mark for allowed clients using the client_mark map
        ip saddr @allowed_clients meta mark set ip saddr map @client_mark_u;
        ip daddr @allowed_clients meta mark set ip daddr map @client_mark_d;
    }
    
    # Основная фильтрация: разрешаем только whitelisted клиентов идти в интернет
    chain forward {
        type filter hook forward priority 0; policy drop;
        
        # allow established related
        ct state established,related accept;
        
        # LAN -> WAN: только разрешённые клиенты
        iifname @I_LAN ip saddr @allowed_clients oifname  @I_WAN accept;
        
        # LAN <-> LAN внутри сети разрешаем
        iifname @I_LAN oifname @I_LAN accept;
        
        # log and drop others
        log prefix "BLOCKED_CLIENT: " flags all;
        drop;
    }
    
    # Остальные цепочки (input/output) — по умолчанию принимаем (если надо, можно ужесточить)
    chain input {
        type filter hook input priority 0; policy accept;
    }
    
    chain output {
        type filter hook output priority 0; policy accept;
    }
}
