#!/usr/sbin/nft -f

flush ruleset

################################################################
# NAT table (round-robin SNAT pool + static map)
################################################################
table ip nat {
    # Real IP bypass (transit networks) - не NATим
    set real_ip_bypass {
        type ipv4_addr
        flags interval
        elements = { 1.1.1.32/27 }
    }
    
    # Сеть(и) клиентов (можно адаптировать под конкретную подсеть)
    set LOCAL_NET_v4 {
        type ipv4_addr
        flags interval
        auto-merge
        elements = { 10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12 }
    }
    
    # WAN интерфейсы (используется в oifname)
    set I_WAN {
        type ifname
        flags interval
        auto-merge
        elements = { "vlan3310" }
    }
    
    # Map: префикс (или отдельный IP) -> фиксированный внешний IP (persistent SNAT)
    map public_pool_map {
        type ipv4_addr : ipv4_addr
        # ключи могут быть подсетями или отдельными адресами; значения — внешние адреса
        # initially empty; example:
        # elements = { 10.10.162.26 : 1.1.1.192 }
    }
    
    # Map: префикс (или отдельный IP) -> фиксированный внешний IP (persistent SNAT)
    map public_pool_map_static {
        type ipv4_addr : ipv4_addr
        flags interval
        # ключи могут быть подсетями или отдельными адресами; значения — внешние адреса
        elements = {
            10.10.0.0/24 : 1.1.1.192,
            10.10.162.27 : 1.1.1.195,
            # добавляй по необходимости
        }
    }

    chain prerouting {
        type nat hook prerouting priority -100; policy accept;
    }
    
    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;
        
        # 1) Не NATим traffic от реального пула (он маршрутится напрямую)
        ip saddr @real_ip_bypass return;
        
        # 2) Если есть статическая привязка (map) — используем её и делаем persistent SNAT, создается скриптом userctl
#        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to ip saddr map @public_pool_map persistent;
        
        # 3) Если есть статическая привязка (map) — используем её и делаем persistent SNAT
#        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to ip saddr map @public_pool_map_static persistent;
        
        # 4) Если статической привязки нет — используй round-robin диапазон (sticky per-conn)
#        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to 1.1.1.192-1.1.1.222 persistent;
        
        # 5) Фолбэк: обычный masquerade для всего остального, уходящего на WAN
        oifname @I_WAN masquerade;
    }
}

################################################################
# Firewall / marking table (mark ставится для разрешённых клиентов -> используется tc)
################################################################
table inet firewall {
    # Whitelist: клиенты, которым разрешён выход в интернет
    set allowed_clients {
        type ipv4_addr
        flags interval
        #auto-merge
        # initially empty; управлять через nft add element / userctl
    }
    
    # Map: private IP -> fwmark (число)
    # Map for downloads
    map client_mark_d {
        type ipv4_addr : mark
        # элементы добавляются командой nft add element inet firewall client_mark { 10.10.162.26 : 1001 }
    }
    
    # Map: private IP -> fwmark (число)
    # Map for uploads
    map client_mark_u {
        type ipv4_addr : mark
        # элементы добавляются командой nft add element inet firewall client_mark { 10.10.162.26 : 1001 }
    }

    # WAN and LAN sets (локально в этой таблице, для удобства)
    set I_LAN {
        type ifname
        flags interval
        elements = { "vlan165" }
    }
    set I_WAN {
        type ifname
        flags interval
        elements = { "vlan3310" }
    }
    
    # Mangle: проставление meta mark ТОЛЬКО для разрешённых клиентов
    chain mangle_pre {
        type filter hook prerouting priority mangle;  policy accept;
        
        # set meta mark for allowed clients using the client_mark map
        #ip saddr @allowed_clients meta mark set ip saddr map @client_mark_u;
        #ip daddr @allowed_clients meta mark set ip daddr map @client_mark_d;

	meta mark != 0 counter log prefix "MARKED: ";

    }

    # UPLOAD: клиент → интернет (до SNAT)
    chain mangle_up {
        type filter hook prerouting priority mangle; policy accept;
        iifname @I_LAN ip saddr @allowed_clients meta mark set ip saddr map @client_mark_u  counter log prefix "UP_MARK: ";
    }

    # DOWNLOAD: интернет → клиент (daddr уже внутренний)
    chain mangle_down {
        type filter hook postrouting priority 100; policy accept;
        oifname @I_LAN ip daddr @allowed_clients meta mark set ip daddr map @client_mark_d counter log prefix "DOWN_MARK: "
    }
    
    # Основная фильтрация: разрешаем только whitelisted клиентов идти в интернет
    chain forward {
        type filter hook forward priority 0; policy drop;
        
        # allow established related
        ct state established,related accept;
        
        # LAN -> WAN: только разрешённые клиенты
        iifname @I_LAN ip saddr @allowed_clients oifname  @I_WAN accept;
        
        # LAN -> WAN: только разрешённые клиенты
        iifname @I_WAN ip daddr @allowed_clients oifname  @I_LAN accept;

        # LAN <-> LAN внутри сети разрешаем
        iifname @I_LAN oifname @I_LAN accept;
        
        # log and drop others
        log prefix "BLOCKED_CLIENT: " flags all;
        drop;
    }
    
    # Остальные цепочки (input/output) — по умолчанию принимаем (если надо, можно ужесточить)
    chain input {
        type filter hook input priority 0; policy accept;
    }
    
    chain output {
        type filter hook output priority 0; policy accept;
    }
}
