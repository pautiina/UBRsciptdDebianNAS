#!/usr/sbin/nft -f

flush ruleset

################################################################
# NAT table (round-robin SNAT pool + static map)
################################################################
table ip nat {
    ct helper ftp-standard {
        type "ftp" protocol tcp;
    }
    ct helper sip-5060 {
        type "sip" protocol udp;
    }
    ct helper tftp-69 {
        type "tftp" protocol udp;
    }

    # Real IP bypass (transit networks) - не NATим
    set real_ip_bypass {
        type ipv4_addr
        flags interval
        elements = { 1.1.1.32/27 }
    }
    
    # Сеть(и) клиентов (можно адаптировать под конкретную подсеть)
    set LOCAL_NET_v4 {
        type ipv4_addr
        flags interval
        auto-merge
        elements = { 10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12 }
    }
    
    # WAN интерфейсы (используется в oifname)
    set I_WAN {
        type ifname
        flags interval
        auto-merge
        elements = { "vlan3310" }
    }
    
    # Map: префикс (или отдельный IP) -> фиксированный внешний IP (persistent SNAT)
    map public_pool_map {
        type ipv4_addr : ipv4_addr
        # ключи могут быть подсетями или отдельными адресами; значения — внешние адреса
        # initially empty; example:
        # elements = { 10.10.162.26 : 1.1.1.192 }
    }
    
    # Map: префикс (или отдельный IP) -> фиксированный внешний IP (persistent SNAT)
    map public_pool_map_static {
        type ipv4_addr : ipv4_addr
        flags interval
        # ключи могут быть подсетями или отдельными адресами; значения — внешние адреса
        elements = {
            10.10.0.0/24 : 1.1.1.192,
            10.10.162.27 : 1.1.1.195,
            # добавляй по необходимости
        }
    }

    chain prerouting {
        type nat hook prerouting priority -100; policy accept;

        ct state new ct helper set ip protocol . th dport map { \
                        udp . 69 : "tftp-69", \
                        udp . 5060 : "sip-5060", \
                        tcp . 21 : "ftp-standard" } ;
    }
    
    chain postrouting {
        #type nat hook postrouting priority 100; policy accept;
        type nat hook postrouting priority srcnat; policy accept;
        
        # 1) Не NATим traffic от реального пула (он маршрутится напрямую)
        ip saddr @real_ip_bypass return;
        
        # 2) Если есть статическая привязка (map) — используем её и делаем persistent SNAT, создается скриптом userctl
#        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to ip saddr map @public_pool_map persistent;
        
        # 3) Если есть статическая привязка (map) — используем её и делаем persistent SNAT
#        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to ip saddr map @public_pool_map_static persistent;
        
        # 4) Если статической привязки нет — используй round-robin диапазон (sticky per-conn)
#        ip saddr @LOCAL_NET_v4 oifname @I_WAN snat to 1.1.1.192-1.1.1.222 persistent;
        
        # 5) Фолбэк: обычный masquerade для всего остального, уходящего на WAN
        oifname @I_WAN masquerade;
    }
}

################################################################
# Firewall / marking table (mark ставится для разрешённых клиентов -> используется tc)
################################################################
table inet firewall {
    # Whitelist: хости, які доступні навіть при виключеному інтернеті
    set allowed_hosts {
        type ipv4_addr
        flags interval
	elements = { 46.172.83.106 }
    }

    # Whitelist: клиенты, которым разрешён выход в интернет
    set allowed_clients {
        type ipv4_addr
        flags interval
        #auto-merge
    }
    
    # Map: private IP -> fwmark (число)
    # Map for downloads
    map client_mark_d {
        type ipv4_addr : mark
        # элементы добавляются командой nft add element inet firewall client_mark { 10.10.162.26 : 1001 }
    }
    
    # Map: private IP -> fwmark (число)
    # Map for uploads
    map client_mark_u {
        type ipv4_addr : mark
        # элементы добавляются командой nft add element inet firewall client_mark { 10.10.162.26 : 1001 }
    }

    # WAN and LAN sets (локально в этой таблице, для удобства)
    set I_LAN {
        type ifname
        flags interval
        elements = { "vlan165" }
    }
    set I_WAN {
        type ifname
        flags interval
        elements = { "vlan3310" }
    }
    
    # Mangle: проставление meta mark ТОЛЬКО для разрешённых клиентов
    chain mangle_pre {
        type filter hook prerouting priority mangle;  policy accept;
        
        # set meta mark for allowed clients using the client_mark map
        #ip saddr @allowed_clients meta mark set ip saddr map @client_mark_u;
        #ip daddr @allowed_clients meta mark set ip daddr map @client_mark_d;

#	meta mark != 0 counter log prefix "MARKED: ";

    }

    # UPLOAD: клиент → интернет (до SNAT)
    chain mangle_up {
        type filter hook prerouting priority mangle; policy accept;
        #iifname @I_LAN ip saddr @allowed_clients meta mark set ip saddr map @client_mark_u mark set meta mark counter log prefix "UP_MARK: ";
        iifname @I_LAN ip saddr @allowed_clients meta mark set ip saddr map @client_mark_u mark set meta mark;
    }

    # DOWNLOAD: интернет → клиент (daddr уже внутренний)
    chain mangle_down {
        type filter hook postrouting priority 100; policy accept;
        #oifname @I_LAN ip daddr @allowed_clients meta mark set ip daddr map @client_mark_d counter log prefix "DOWN_MARK: ";
        oifname @I_LAN ip daddr @allowed_clients meta mark set ip daddr map @client_mark_d;
    }
    
    # Основная фильтрация: разрешаем только whitelisted клиентов идти в интернет
    chain forward {
        type filter hook forward priority 0; policy drop;

        # Разрешаем все соединения на петлевом интерфейсе
        iif "lo" accept
        
        # allow established related
#        ct state established,related accept;
	ct state vmap { established : accept, related : accept, invalid : drop }
        
        # LAN -> WAN: дозволені хости
        iifname @I_LAN ip daddr @allowed_hosts oifname  @I_WAN accept;
        
        # LAN -> WAN: дозволені хости
        iifname @I_WAN ip saddr @allowed_hosts oifname  @I_LAN accept;

        # LAN -> WAN: только разрешённые клиенты
        iifname @I_LAN ip saddr @allowed_clients oifname  @I_WAN accept;
        
        # LAN -> WAN: только разрешённые клиенты
        iifname @I_WAN ip daddr @allowed_clients oifname  @I_LAN accept;

        # LAN <-> LAN внутри сети разрешаем
        iifname @I_LAN oifname @I_LAN accept;
        
        # log and drop others
        limit rate over 1/second  log prefix "BLOCKED_CLIENT: " flags all;
        drop;
    }
    
    # Остальные цепочки (input/output) — по умолчанию принимаем (если надо, можно ужесточить)
    chain input {
        type filter hook input priority 0; policy accept;

        # Разрешаем все соединения на петлевом интерфейсе
        iif "lo" accept;

        # Разрешаем уже установленные соединения
        ct state vmap { established : accept, related : accept, invalid : drop };
    }
    
    chain output {
        type filter hook output priority 0; policy accept;

        # Разрешаем все исходящие соединения
        oif "lo" accept;

        # Разрешаем уже установленные соединения
        ct state vmap { established : accept, related : accept, invalid : drop };

        # Разрешаем Интернет на шлюзе
        tcp dport { 80, 443 } accept;

        # Разрешаем DNS
        meta l4proto { tcp, udp } th dport 53 accept;

        # Разрешаем исходящий ICMP request (ping)
        icmp type echo-request accept;

        # Разрешаем NTP
        udp dport 123 accept;
    }
}
